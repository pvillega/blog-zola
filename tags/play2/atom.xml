<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="https://perevillega.com/feed_style.xsl" type="text/xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <tabi:metadata xmlns:tabi="https://github.com/welpo/tabi">
        <tabi:separator>
            •
        </tabi:separator>
        <tabi:about_feeds>This is a web feed, also known as an Atom feed. Subscribe by copying the URL from the address bar into your newsreader. Visit About Feeds to learn more and get started. It&#x27;s free.</tabi:about_feeds>
        <tabi:visit_the_site>Visit website</tabi:visit_the_site>
        <tabi:recent_posts>Recent posts</tabi:recent_posts>
        <tabi:last_updated_on>Updated on $DATE</tabi:last_updated_on>
        <tabi:default_theme></tabi:default_theme>
        <tabi:post_listing_date>date</tabi:post_listing_date>
        <tabi:current_section>play2</tabi:current_section>
    </tabi:metadata><title>Software serves the Business - play2</title>
        <subtitle>Pere Villega&#x27;s blog</subtitle>
    <link href="https://perevillega.com/tags/play2/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://perevillega.com/tags/play2/" rel="alternate" type="text/html"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2014-01-10T00:00:00+00:00</updated>
    <id>https://perevillega.com/tags/play2/atom.xml</id><entry xml:lang="en">
        <title>Twilio and Play Framework</title>
        <published>2014-01-10T00:00:00+00:00</published>
        <updated>2014-01-10T00:00:00+00:00</updated>
        <author>
            <name>Pere Villega</name>
        </author>
        <link rel="alternate" href="https://perevillega.com/posts/twilio-and-play-framework/" type="text/html"/>
        <id>https://perevillega.com/posts/twilio-and-play-framework/</id>
        
            <content type="html">&lt;p&gt;Another year, more technology to test :) Busy as I am in &lt;a href=&quot;http:&#x2F;&#x2F;www.gumtree.com&#x2F;&quot;&gt;Gumtree&lt;&#x2F;a&gt;, I&#x27;ve been able to test some interesting stuff. You know, evaluation of technologies to see if they make sense from a business perspective. Or playing around, it depends on the point of view ;)&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This time the testing platform has been &lt;a href=&quot;https:&#x2F;&#x2F;www.twilio.com&#x2F;&quot;&gt;Twilio&lt;&#x2F;a&gt;. I built a prototype using Play Framework, Scala and the Twilio API to see how things work and if we could use some of them in the site. Granted, by prototype I mean 2 pages to test some calls to the API, but I guess this covers the core of Twilio, and extending it should be quite straightforward.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve written about it in a post in the &lt;a href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@GumtreeDevTeam&#x2F;using-twilio-from-within-play-framework-81b174e31a84&quot;&gt;Gumtree dev blog&lt;&#x2F;a&gt;, where I also link to the sample code in Github.&lt;&#x2F;p&gt;
&lt;p&gt;As always, feedback via Twitter&#x2F;Email is more than welcome.&lt;&#x2F;p&gt;
&lt;p&gt;Oh, and Happy 2014! May the (reactive?) code be with you ;)&lt;&#x2F;p&gt;
</content>
        <summary type="html">Another year, more technology to test :) Busy as I am in Gumtree, I've been able to test some interesting stuff. You know, evaluation of technologies to see if they make sense from a business perspective. Or playing around, it depends on the point of view ;)
…</summary>
        </entry><entry xml:lang="en">
        <title>Using Ansible to deploy Play Framework apps in EC2 instances</title>
        <published>2013-04-01T00:00:00+00:00</published>
        <updated>2013-04-01T00:00:00+00:00</updated>
        <author>
            <name>Pere Villega</name>
        </author>
        <link rel="alternate" href="https://perevillega.com/posts/using-ansible-to-deploy-play-framework-apps-in-ec2-instances/" type="text/html"/>
        <id>https://perevillega.com/posts/using-ansible-to-deploy-play-framework-apps-in-ec2-instances/</id>
        
            <content type="html">&lt;p&gt;&lt;strong&gt;TL;DR:&lt;&#x2F;strong&gt; Clone &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pvillega&#x2F;ansible-ec2-play&quot;&gt;Ansible for Play Framework&lt;&#x2F;a&gt; to automate the task of deploying Play 2.x projects from a git repository into an EC2 instance.&lt;&#x2F;p&gt;
&lt;p&gt;As many developers I&#x27;m not a good sysadmin. That&#x27;s why I was happy to see the raise of PaaS like &lt;a href=&quot;http:&#x2F;&#x2F;www.heroku.com&#x2F;&quot;&gt;Heroku&lt;&#x2F;a&gt;, which facilitated deploying a webapp without having to spend time in sysadmin tasks which I didn&#x27;t know how to do correctly and which took me too much time.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;Unfortunately, as with most abstractions, the PaaS environments are simple to use but also quite limited in options. Heroku offering of 512Mb per dyno plus limitations on what you can do can be a problem, and the third party addons get expensive quickly. Then you have Amazon EC2, cheaper and quite flexible, but in exchange you need a bit more of &quot;sysadmin knowledge&quot;. Not a big deal for apps like this blog, running in a Micro instance, but if your app is bigger and spans several servers, it may become time consuming.&lt;&#x2F;p&gt;
&lt;p&gt;I wanted to automate the task of managing the server so I did not have to worry too much about it. I looked at both &lt;a href=&quot;http:&#x2F;&#x2F;www.opscode.com&#x2F;chef&#x2F;&quot;&gt;Chef&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;puppetlabs.com&#x2F;&quot;&gt;Puppet&lt;&#x2F;a&gt;, but somehow I couldn&#x27;t bring myself to spend enough time with them. The release of &lt;a href=&quot;http:&#x2F;&#x2F;aws.amazon.com&#x2F;opsworks&#x2F;&quot;&gt;Amazon OpsWorks&lt;&#x2F;a&gt; raised the issue again as they don&#x27;t have a Play Framework 2 script ready out of the box, but it was hard to try to focus on that task.&lt;&#x2F;p&gt;
&lt;p&gt;That was it until this last weekend when I discovered, somehow, &lt;a href=&quot;http:&#x2F;&#x2F;ansible.cc&#x2F;&quot;&gt;Ansible&lt;&#x2F;a&gt;. Ansible is a tool in the same category as Chef and Puppet (purists will start pointing at relevant differences here, but I only care about the fact that they automate my sysadmin tasks). For some reason Ansible seemed much simpler to understand and use, and I got hooked. Ansible Playbooks consist on a series of yaml files that declare the steps to execute, in order. Ansible itself manages the execution of the steps across servers, so you can run one script on as many servers as you need all at the same time. I won&#x27;t enter into details as &lt;a href=&quot;http:&#x2F;&#x2F;ansible.cc&#x2F;&quot;&gt;Ansible&lt;&#x2F;a&gt; has good enough documentation, but to put an example let&#x27;s see a possible Ansible Playbook to install &lt;code&gt;Authbind&lt;&#x2F;code&gt; into an EC2 instance:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    # Run with: ansible-playbook -i hosts.ini playenv.yaml -u ubuntu
    ---
    - hosts: ec2Instance
      vars:
      - ubuntu_release: quantal

    tasks:
      - name: Install Authbind
        action: apt pkg=authbind state=latest install_recommends=yes
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Having the tool the task ahead was clear: my main 3 sysadmin issues with EC2 (given my current usage level) are securing the Ubuntu AMI, deploying a Play environment and deploying the app itself. With Ansible, I should be able to automate these steps so I won&#x27;t do mistakes like forgetting one step as well as reducing the time I have to spend on these tasks.&lt;&#x2F;p&gt;
&lt;p&gt;It wasn&#x27;t easy (as I said I&#x27;m not a sysadmin) and the scripts could be better, but I managed to create something that works: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pvillega&#x2F;ansible-ec2-play&quot;&gt;Ansible for Play Framework in EC2&lt;&#x2F;a&gt;. Instructions for execution are included in the Github repository.&lt;&#x2F;p&gt;
&lt;p&gt;There are 3 relevant scripts:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;bootstrap.yaml:&lt;&#x2F;strong&gt; runs a series of commands to enhance security of an EC2 Ubuntu AMI. I&#x27;m not a sysadmin so some step may be wrong or incomplete, but what&#x27;s in there seems to work fine. Requires sudo privilege in the target machine to run.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;playenv.yaml:&lt;&#x2F;strong&gt; sets some Play Framework dependencies (basically pvm and java 7) as well as Authbind so Play can use port 80 without root privileges. Requires sudo privilege in the target machine to run.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;deploy.yaml:&lt;&#x2F;strong&gt; clones a Play project from a given Git repository and deploys it on the target machine. The script assumes the repository contains a &lt;code&gt;start&lt;&#x2F;code&gt; file in the format provided with the script (see &lt;code&gt;exec&lt;&#x2F;code&gt; folder) to be able to successfully launch the app. Customise the &lt;code&gt;start&lt;&#x2F;code&gt; file as required. No sudo required, the script uses authbind to link Play to port 80. Be aware that in EC2 Micro instances this script will fail due to low memory as Linux memory manager kills the JVM when building the distributable zip for the app.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If you have a project in Github (or any publicly available Git repository) and an EC2 instance, run the scripts through Ansible and there you go, app deployed and running!&lt;&#x2F;p&gt;
&lt;p&gt;So, that&#x27;s all. If you see something that can be improved, please contribute with a pull request. I hope with this you can save some time on your next deployment.&lt;&#x2F;p&gt;
</content>
        <summary type="html">TL;DR: Clone Ansible for Play Framework to automate the task of deploying Play 2.x projects from a git repository into an EC2 instance.
As many developers I'm not a good sysadmin. That's why I was happy to see the raise of PaaS like Heroku, which facilitated deploying a webapp without having to spend time in sysadmin tasks which I didn't know how to do correctly and which took me too much time.
…</summary>
        </entry><entry xml:lang="en">
        <title>Using Redis PubSub with Play 2.1.0</title>
        <published>2013-02-24T00:00:00+00:00</published>
        <updated>2013-02-24T00:00:00+00:00</updated>
        <author>
            <name>Pere Villega</name>
        </author>
        <link rel="alternate" href="https://perevillega.com/posts/using-redis-pubsub-with-play-2-dot-1-0/" type="text/html"/>
        <id>https://perevillega.com/posts/using-redis-pubsub-with-play-2-dot-1-0/</id>
        
            <content type="html">&lt;p&gt;Last week I was experimenting a bit with &lt;a href=&quot;http:&#x2F;&#x2F;redis.io&#x2F;&quot;&gt;Redis&lt;&#x2F;a&gt; and its &lt;a href=&quot;http:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;pubsub&quot;&gt;Publish-Subscribe&lt;&#x2F;a&gt; module. The idea was to try to implement a chat with it (something I&#x27;ll need for my next project) and from all the options I evaluated this seemed the best. Loving Redis so far, whoever called it the swiss-knife of databases was completely right.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;As to be expected with programming I had some trouble, in this scenario using Redis PubSub with Play 2.1.0 blocked the application. So I decided to publish this in case someone else has the same issue. If you don&#x27;t want to read the details just go to the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pvillega&#x2F;play21-redis-pubsub&quot;&gt;GitHub repository&lt;&#x2F;a&gt; and clone the source. It contains a very simple application in which Play subscribes to a Redis channel and sends messages to it via Akka actors, while using a listener to notify about reception of the same messages. The &lt;code&gt;Readme&lt;&#x2F;code&gt; file gives more detail on how it works.&lt;&#x2F;p&gt;
&lt;p&gt;So now let&#x27;s talk about Redis and the issue I had.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;using-redis-with-play&quot;&gt;&lt;a class=&quot;header-anchor no-hover-padding&quot; href=&quot;#using-redis-with-play&quot; aria-label=&quot;Anchor link for: using-redis-with-play&quot;&gt;&lt;span class=&quot;link-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;
Using Redis with Play&lt;&#x2F;h2&gt;
&lt;p&gt;Using Redis with Play is very straightforward. Typesafe provides a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;typesafehub&#x2F;play-plugins&#x2F;tree&#x2F;master&#x2F;redis&quot;&gt;play plugin&lt;&#x2F;a&gt; to manage the interactions. The plugin is based on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pk11&#x2F;sedis&quot;&gt;Sedis&lt;&#x2F;a&gt;, the Scala library for Redis, which in turn is a wrapper over &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;xetorthio&#x2F;jedis&#x2F;&quot;&gt;Jedis&lt;&#x2F;a&gt;, the most popular JVM library for Redis.&lt;&#x2F;p&gt;
&lt;p&gt;At the time of this writing the dependencies for Play 2.1 are not working perfectly so you need to add an additional resolver to your project to be able to download all of them:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;resolvers += &amp;quot;org.sedis&amp;quot; at &amp;quot;http:&amp;#x2F;&amp;#x2F;pk11-scratch.googlecode.com&amp;#x2F;svn&amp;#x2F;trunk&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;but once done you can use Redis as both Cache layer and Database for Play.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-issue&quot;&gt;&lt;a class=&quot;header-anchor no-hover-padding&quot; href=&quot;#the-issue&quot; aria-label=&quot;Anchor link for: the-issue&quot;&gt;&lt;span class=&quot;link-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;
The issue&lt;&#x2F;h2&gt;
&lt;p&gt;Simple as it is, things got a bit more complex when using PubSub. The way PubSub works with Redis is as follows:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;first of all you set a client to subscribe to a channel. The subscription call accepts a listener class that will trigger method calls as response to events in the channel (messages being passed around, etc.)&lt;&#x2F;li&gt;
&lt;li&gt;then you need clients to send messages to the channel via the &lt;code&gt;publish&lt;&#x2F;code&gt; operation.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;So the resulting code for subscription would be something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;pool.withJedisClient{ client =&amp;gt;
  client.subscribe(listener, CHANNEL)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;but as it happens &lt;code&gt;subscribe&lt;&#x2F;code&gt; is a blocking call. This means that every time we execute it, a thread will be locked into receiving notifications from Redis. And the result is that Play will stop working as all threads get consumed by calls to this operation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;solution&quot;&gt;&lt;a class=&quot;header-anchor no-hover-padding&quot; href=&quot;#solution&quot; aria-label=&quot;Anchor link for: solution&quot;&gt;&lt;span class=&quot;link-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;
Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Thankfully Play 2.1.0 introduces a new concept that solves this issue: &lt;a href=&quot;http:&#x2F;&#x2F;www.playframework.com&#x2F;documentation&#x2F;2.1.0&#x2F;ThreadPools&quot;&gt;ExecutionContexts&lt;&#x2F;a&gt;. An &lt;code&gt;ExecutionContext&lt;&#x2F;code&gt; is nothing more than a set of threads, independent from the ones managing the Play app itself, to be used when we have slow or blocking operations. This ensures some specialized thread takes care of that operation without impacting the performance of the application itself.&lt;&#x2F;p&gt;
&lt;p&gt;In our case, as we have a blocking call, we simply want to run the &lt;code&gt;subscribe&lt;&#x2F;code&gt; operation inside its own &lt;code&gt;ExecutionContext&lt;&#x2F;code&gt;, which will consist on threads devoted to listening to Redis, while the standard &lt;code&gt;ExecutionContext&lt;&#x2F;code&gt; manages other Play calls. So our code will become as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;object Contexts {
  &amp;#x2F;&amp;#x2F; Execution context used to avoid blocking on subscribe
  implicit val myExecutionContext: ExecutionContext =
Akka.system.dispatchers.lookup(&amp;quot;akka.actor.redis-pubsub-context&amp;quot;)
}

Future {
  &amp;#x2F;&amp;#x2F; subscribe in a Future using a specific ExecutionContext
  &amp;#x2F;&amp;#x2F; use Sedis pool to launch the subscribe operation
  pool.withJedisClient{ client =&amp;gt;
    client.subscribe(listener, CHANNEL)
  }
}(Contexts.myExecutionContext)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And that&#x27;s it. A simple way to avoid blocking operations slowing your app or consuming all the threads it needs. If you&#x27;ve had this issue this will solve it for you.&lt;&#x2F;p&gt;
</content>
        <summary type="html">Last week I was experimenting a bit with Redis and its Publish-Subscribe module. The idea was to try to implement a chat with it (something I'll need for my next project) and from all the options I evaluated this seemed the best. Loving Redis so far, whoever called it the swiss-knife of databases was completely right.
…</summary>
        </entry><entry xml:lang="en">
        <title>Executing Jasmine Tests in Play 2.0.4</title>
        <published>2013-01-26T00:00:00+00:00</published>
        <updated>2013-01-26T00:00:00+00:00</updated>
        <author>
            <name>Pere Villega</name>
        </author>
        <link rel="alternate" href="https://perevillega.com/posts/executing-jasmine-tests-in-play-2-dot-0-4/" type="text/html"/>
        <id>https://perevillega.com/posts/executing-jasmine-tests-in-play-2-dot-0-4/</id>
        
            <content type="html">&lt;p&gt;&lt;em&gt;Christmas&lt;&#x2F;em&gt; break is over, and on a whim I started to check &lt;a href=&quot;http:&#x2F;&#x2F;angularjs.org&#x2F;&quot;&gt;AngularJs&lt;&#x2F;a&gt;. If you haven&#x27;t tested it yet, do it. I&#x27;ve toyed around  with Backbone and some other Javascript &lt;em&gt;single page app&lt;&#x2F;em&gt; frameworks, and Angular is by far the one that I liked the most. It has simplicity embedded in its core, and turning tedious tasks (as setting controllers) into something trivial makes it a pleasure to use. Simplicity. Such an important concept, and one which is seldom present in frameworks.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;But I digress. Back to the post. Adding Angular to a Play app is as simple as you can imagine, as in the end it&#x27;s a Javascript library. Add the Angular files, code controllers and services, put Angular templates under &lt;code&gt;public&lt;&#x2F;code&gt; so Angular can get them, and you are done.  You can see a project sample &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pvillega&#x2F;play2demo-jasmine&quot;&gt;in my Github account&lt;&#x2F;a&gt;. Be aware the sample is very rough and has minimal functionality, the aim was to see how can they be linked, not to push Angular boundaries.&lt;&#x2F;p&gt;
&lt;p&gt;So we have a Javascript framework, and obviously we want to test it. Unfortunately the recommended way to test Angular is via &lt;a href=&quot;http:&#x2F;&#x2F;pivotal.github.com&#x2F;jasmine&#x2F;&quot;&gt;Jasmine&lt;&#x2F;a&gt;, a Javascript BDD framework. I say unfortunately because that would mean running 2 commands for testing: one for Play tests and another for Angular tests. Or does it?&lt;&#x2F;p&gt;
&lt;p&gt;It is on moments like this when Open Source shows its worthiness. Enter &lt;a href=&quot;http:&#x2F;&#x2F;www.guardian.co.uk&#x2F;&quot;&gt;The Guardian&lt;&#x2F;a&gt; and its Software development department, which open sources a lot of the code they create to run their online platform. A wise company, they use Scala and Play and they created &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;guardian&#x2F;sbt-jasmine-plugin&quot;&gt;Sbt-Jasmine&lt;&#x2F;a&gt;, a plugin to run Jasmine inside Sbt projects. Given that Play 2 uses Sbt, this should prove simple.&lt;&#x2F;p&gt;
&lt;p&gt;Well, to be honest it wasn&#x27;t &lt;em&gt;so&lt;&#x2F;em&gt; simple, that&#x27;s why I decided to document it here to save time to other interested people. This assumes a working Play 2.0.4 project, should work with any 2.0.x project but can&#x27;t promise anything about 2.1 (have to test it yet)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;integrating-sbt-jasmine&quot;&gt;&lt;a class=&quot;header-anchor no-hover-padding&quot; href=&quot;#integrating-sbt-jasmine&quot; aria-label=&quot;Anchor link for: integrating-sbt-jasmine&quot;&gt;&lt;span class=&quot;link-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;
Integrating Sbt-Jasmine&lt;&#x2F;h2&gt;
&lt;p&gt;This is quite straightforward, you just need to follow the instructions from the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;guardian&#x2F;sbt-jasmine-plugin&quot;&gt;Sbt-Jasmine&lt;&#x2F;a&gt; page. On your project, under the &lt;code&gt;project&lt;&#x2F;code&gt; folder, create another folder named &lt;code&gt;project&lt;&#x2F;code&gt; (that is, you will have &lt;code&gt;&#x2F;project&#x2F;project&#x2F;&lt;&#x2F;code&gt; path). Inside that new folder create a file &lt;code&gt;Plugins.scala&lt;&#x2F;code&gt; and add this code to it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;
import sbt._


&amp;#x2F;&amp;#x2F; This plugin is used to load the sbt-jasmine plugin into our project.
&amp;#x2F;&amp;#x2F; This allows us to import the SbtJasminePlugin file
&amp;#x2F;&amp;#x2F; in Build.scala, and then set the settings and configuration for Sbt-Jasmine
object Plugins extends Build {
  lazy val plugins = Project(&amp;quot;plugins&amp;quot;, file(&amp;quot;.&amp;quot;))
    .dependsOn(uri(&amp;quot;git:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;guardian&amp;#x2F;sbt-jasmine-plugin.git#0.7&amp;quot;))
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will load the plugin directly from Github into your project.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;adding-jasmine-as-part-of-your-test-cycle&quot;&gt;&lt;a class=&quot;header-anchor no-hover-padding&quot; href=&quot;#adding-jasmine-as-part-of-your-test-cycle&quot; aria-label=&quot;Anchor link for: adding-jasmine-as-part-of-your-test-cycle&quot;&gt;&lt;span class=&quot;link-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;
Adding Jasmine  as part of your test cycle&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have the plugin in, we want to be able to run both test types (Play and Jasmine) when executing &lt;code&gt;play test&lt;&#x2F;code&gt;. To that aim we have to edit our &lt;code&gt;Build.scala&lt;&#x2F;code&gt; project file to let Play know about Jasmine.&lt;&#x2F;p&gt;
&lt;p&gt;The first step will be importing the existing Jasmine settings the sbt plugin added into the project. We can do that via the &lt;code&gt;PlayProject&lt;&#x2F;code&gt; method &lt;code&gt;settings&lt;&#x2F;code&gt;, as in &lt;code&gt;.settings(jasmineSettings : _*)&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The second step is to override the default Jasmine configuration, specifically the paths that point to the test assets and source files. Sbt-Jasmine expects a set of default paths that don&#x27;t map to the ones existing in a Play project, so we change them as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;

&amp;#x2F;&amp;#x2F; jasmine configuration, overridden as we don&amp;#x27;t follow the default
&amp;#x2F;&amp;#x2F; project structure sbt-jasmine expects

appJsDir &amp;lt;+= baseDirectory &amp;#x2F; &amp;quot;app&amp;#x2F;assets&amp;#x2F;javascripts&amp;quot;,
appJsLibDir &amp;lt;+= baseDirectory &amp;#x2F; &amp;quot;public&amp;#x2F;javascripts&amp;#x2F;lib&amp;quot;,
jasmineTestDir &amp;lt;+= baseDirectory &amp;#x2F; &amp;quot;test&amp;#x2F;assets&amp;#x2F;&amp;quot;,
jasmineConfFile &amp;lt;+= baseDirectory &amp;#x2F; &amp;quot;test&amp;#x2F;assets&amp;#x2F;test.dependencies.js&amp;quot;,

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that &lt;code&gt;appJsDir&lt;&#x2F;code&gt; is pointing to the folder for minimized assets, we could change that to point to &lt;code&gt;&quot;public&#x2F;Javascripts&quot;&lt;&#x2F;code&gt;. The paths for &lt;code&gt;appJsLibDir&lt;&#x2F;code&gt;, &lt;code&gt;jasmineTestDir&lt;&#x2F;code&gt; and &lt;code&gt;jasmineConfFile&lt;&#x2F;code&gt; can be modified as it suits you.&lt;&#x2F;p&gt;
&lt;p&gt;The Jasmine configuration file follows standard Jasmine notation, which I won&#x27;t discuss in this post. The configuration for this sample project is:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;
&amp;#x2F;&amp;#x2F; Dependencies for the unit test via Jasmine
EnvJasmine.loadGlobal(EnvJasmine.libDir + &amp;quot;jquery-1.8.3.min.js&amp;quot;);
EnvJasmine.loadGlobal(EnvJasmine.libDir + &amp;quot;angular.min.js&amp;quot;);
EnvJasmine.loadGlobal(EnvJasmine.libDir + &amp;quot;angular-resource.min.js&amp;quot;);
EnvJasmine.loadGlobal(EnvJasmine.testDir + &amp;quot;config&amp;#x2F;angular-mocks.js&amp;quot;);

&amp;#x2F;&amp;#x2F; Import all modules (RequireJs fails for some reason)
&amp;#x2F;&amp;#x2F; FIXME: check why we can&amp;#x27;t use RequireJs
EnvJasmine.loadGlobal(EnvJasmine.rootDir + &amp;quot;todo.js&amp;quot;);

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Finally we need to tell Play to run Jasmine tests when executing the &lt;code&gt;test&lt;&#x2F;code&gt; command. We do this by adding a dependency on &lt;code&gt;test&lt;&#x2F;code&gt; with  &lt;code&gt;(test in Test) &amp;lt;&amp;lt;= (test in Test) dependsOn (jasmine)&lt;&#x2F;code&gt;. This will cause Play to run first the Jasmine tests and, if they succeed, Play own tests will be executed.&lt;&#x2F;p&gt;
&lt;p&gt;The final code looks like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;
val main = PlayProject(appName, appVersion,
 appDependencies, mainLang = SCALA)
&amp;#x2F;&amp;#x2F;this adds jasmine settings from the sbt-jasmine plugin into the project
.settings(jasmineSettings : _*)
.settings(

  &amp;#x2F;&amp;#x2F; Add your own project settings here

  &amp;#x2F;&amp;#x2F; jasmine configuration overridden
  appJsDir &amp;lt;+= baseDirectory &amp;#x2F; &amp;quot;app&amp;#x2F;assets&amp;#x2F;javascripts&amp;quot;,
  appJsLibDir &amp;lt;+= baseDirectory &amp;#x2F; &amp;quot;public&amp;#x2F;javascripts&amp;#x2F;lib&amp;quot;,
  jasmineTestDir &amp;lt;+= baseDirectory &amp;#x2F; &amp;quot;test&amp;#x2F;assets&amp;#x2F;&amp;quot;,
  jasmineConfFile &amp;lt;+= baseDirectory &amp;#x2F; &amp;quot;test&amp;#x2F;assets&amp;#x2F;test.dependencies.js&amp;quot;,

  &amp;#x2F;&amp;#x2F; link jasmine to the standard &amp;#x27;sbt test&amp;#x27; action.
  &amp;#x2F;&amp;#x2F; Now when running &amp;#x27;test&amp;#x27; jasmine tests will be run
  &amp;#x2F;&amp;#x2F; and after that other Play tests will be executed.
  (test in Test) &amp;lt;&amp;lt;= (test in Test) dependsOn (jasmine)
)

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And that&#x27;s all. If you add some Jasmine tests under &lt;code&gt;test&#x2F;assets&lt;&#x2F;code&gt; and then execute &lt;code&gt;play test&lt;&#x2F;code&gt; you will see them being run. Remember what I said about simplicity? Why should you remember to run 2 suits independently when 1 command can do that for you?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;to-be-improved&quot;&gt;&lt;a class=&quot;header-anchor no-hover-padding&quot; href=&quot;#to-be-improved&quot; aria-label=&quot;Anchor link for: to-be-improved&quot;&gt;&lt;span class=&quot;link-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;
To be improved&lt;&#x2F;h2&gt;
&lt;p&gt;As much as I would like, this is not perfect. I found a couple of issues when integrating Jasmine and Play. Given I&#x27;m not an expert on neither, any help will be appreciated:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In theory you could use &lt;a href=&quot;http:&#x2F;&#x2F;requirejs.org&#x2F;&quot;&gt;RequireJS&lt;&#x2F;a&gt; to import the Javascript sources to test, but it didn&#x27;t work when I tried. Not sure why and for a standard AngularJs distribution we are talking about 5 Javascript files (it could grow if you break them into components), so it doesn&#x27;t seem such a big deal. But it&#x27;s not perfect.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;AngularJs allows you to declare End to End test scenarios, similar to Selenium but inside AngularJs itself. Unfortunately I couldn&#x27;t make them work, as they require a server running. Given the enhanced Selenium support in newer AngularJS versions I expect one could use Play end to end scenarios to test this part, but I need to put more work on it to ensure it is true.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If anyone knows how to fix this, please let me know!&lt;&#x2F;p&gt;
</content>
        <summary type="html">Christmas break is over, and on a whim I started to check AngularJs. If you haven't tested it yet, do it. I've toyed around  with Backbone and some other Javascript single page app frameworks, and Angular is by far the one that I liked the most. It has simplicity embedded in its core, and turning tedious tasks (as setting controllers) into something trivial makes it a pleasure to use. Simplicity. Such an important concept, and one which is seldom present in frameworks.
…</summary>
        </entry><entry xml:lang="en">
        <title>Iteratees and Play 2</title>
        <published>2012-11-18T00:00:00+00:00</published>
        <updated>2012-11-18T00:00:00+00:00</updated>
        <author>
            <name>Pere Villega</name>
        </author>
        <link rel="alternate" href="https://perevillega.com/posts/iteratees-and-play-2/" type="text/html"/>
        <id>https://perevillega.com/posts/iteratees-and-play-2/</id>
        
            <content type="html">&lt;p&gt;From time to time I like to test some new functionality of &lt;a href=&quot;http:&#x2F;&#x2F;www.playframework.org&#x2F;&quot;&gt;Play 2.0&lt;&#x2F;a&gt;. Creating a tiny for-fun project allows me to see that functionality in action, to solve the initial pitfalls related to it and to have a basic sample for later on.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;With Play 2.1 coming closer, and seeing all the new stuff in it (Slick, Scala 2.10, etc) I wanted to test some of the features that I&#x27;ve not been able to use in a &quot;real project&quot;, especially the ones related to Real Time web. When thinking about what to implement I remembered an issue a friend had in his company, an ETL-like process that had to receive data (massive amounts) on one end and store it in several location after processing the data. While not in the mood to create a real system which would be quite complex, having to manage queues and ensuring messages were delivered, that inspired me to plan a minor project in which I could use several interesting technologies: Iteratee, MongoDB, Redis and Akka actors. I&#x27;ve not used any of them very often, so I was sold to the idea :)&lt;&#x2F;p&gt;
&lt;p&gt;You can find the code resulting from this experiment in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pvillega&#x2F;iteratees-test&quot;&gt;my Github repository&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I won&#x27;t start a line-by-line description of the project, the source is there and I believe it&#x27;s quite self-explanatory. But there are some things that are worth mentioning, even if it is just for future reference:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Enumerator.imperative&lt;&#x2F;strong&gt; allows you to push data into the Enumerator manually &lt;strong&gt;and won&#x27;t close the stream&lt;&#x2F;strong&gt; until you say so. I had problems when trying to implement a Html view on the stream, as a non-imperative stream was closing automatically once the data was consumed, not waiting for the next input which was slower than the rate at which the app consumed the Enumerator.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;dev.w3.org&#x2F;html5&#x2F;eventsource&#x2F;&quot;&gt;SSE&lt;&#x2F;a&gt; is great, very performing and with better support than WebSockets. Also, the fact that the browser automatically restores the connection if the link is dropped simplifies the code a lot. But (always a but!) it has a bug in its implementation in Play 2.0.4 where the events won&#x27;t have an Id associated even if you provide the corresponding extractor. Hopefully that will be solved in 2.1. The event name part works, though!&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Concurrent.hub&lt;&#x2F;strong&gt; has a nice trick with the &lt;code&gt;getPatchCord&lt;&#x2F;code&gt; method where you multiplex the stream to several clients at the same time. Saves a lot of memory and CPU.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Akka&lt;&#x2F;strong&gt; actors are as simple, fast and reliable as always. As a &lt;em&gt;veteran&lt;&#x2F;em&gt; Java developer, seeing Actors makes it very very hard to go back to &lt;em&gt;synchronized&lt;&#x2F;em&gt; and all that clutter&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;The combination Iteratee + Actor + MongoDB is &lt;strong&gt;FAST&lt;&#x2F;strong&gt;. When running a test with simulated request every 10ms my computer (a bit old by nowadays standards) didn&#x27;t notice it at all. Low resource consumption and high speed? Go Play!&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Talking about &lt;strong&gt;MongoDB&lt;&#x2F;strong&gt;, I&#x27;ve never been a huge fan of NoSQL and in the past I read many articles which made me doubt about Mongo. Obviously, this is not a real-life system where I can&#x27;t afford to lose data, but it was refreshing to see the simplicity of the approach Mongo takes to storing and retrieving data. With &lt;a href=&quot;http:&#x2F;&#x2F;reactivemongo.org&#x2F;&quot;&gt;ReactiveMongo&lt;&#x2F;a&gt; and Play 2.1 it may be a wonderful support system for non-critical real-time data.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Redis&lt;&#x2F;strong&gt; as a Memcached replacement is good, very good, but the additional methods provided by the API so you can use it as a &lt;em&gt;key store&lt;&#x2F;em&gt; can be a bit confusing. I can&#x27;t say which one is better (Redis or Memcached) but I&#x27;m quite impressed with Redis.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Not much more to add. Feel free to clone the code and play with it. It&#x27;s nothing amazing as code goes, but it shows what you can achieve with just a few lines of Scala and Play :)&lt;&#x2F;p&gt;
</content>
        <summary type="html">From time to time I like to test some new functionality of Play 2.0. Creating a tiny for-fun project allows me to see that functionality in action, to solve the initial pitfalls related to it and to have a basic sample for later on.
…</summary>
        </entry>
</feed>
